　 [엔터티](#엔터티)\
　　 [엔터티의 개념](#엔터티의-개념)\
　　 [엔터티와 인스턴스에 대한 내용과 표기법](#엔터티와-인스턴스에-대한-내용과-표기법)\
　　 [엔터티의 특징](#엔터티의-특징)\
　　　 [가. 업무에서 필요로 하는 정보](#가-업무에서-필요로-하는-정보)\
　　　 [나. 식별이 가능해야 함](#나-식별이-가능해야-함)\
　　　 [다. 인스턴스의 집합](#다-인스턴스의-집합)\
　　　 [라](#라)\
　　　 [업무프로세스에 의해 이용](#업무프로세스에-의해-이용)\
　　　 [마. 속성을 포함](#마-속성을-포함)\
　　　 [바. 관계의](#바-관계의)\
　　　 [존재](#존재)\
　　 [엔터티의 분류](#엔터티의-분류)\
　　　 [다. 엔터티](#다-엔터티)\
　　　 [분류](#분류)\
　　　 [방법의](#방법의)\
　　　 [예](#예)\
　　 [엔터티의 명명](#엔터티의-명명)\
　 [속성](#속성)\
　　 [엔터티, 인스턴스와 속성, 속성값에 대한 내용과 표기법](#엔터티-인스턴스와-속성-속성값에-대한-내용과-표기법)\
　　　 [가. 엔터티, 인스턴스, 속성, 속성값의 관계](#가-엔터티-인스턴스-속성-속성값의-관계)\
　　　 [나. 속성의 표기법](#나-속성의-표기법)\
　　 [속성의 특징](#속성의-특징)\
　　 [속성의 분류](#속성의-분류)\
　　　 [가. 속성의 특성에 따른 분류](#가-속성의-특성에-따른-분류)\
　　　 [나. 엔터티 구성방식에 따른 분류](#나-엔터티-구성방식에-따른-분류)\
　　 [도메인(Domain)](#도메인domain)\
　　 [속성의 명명(Naming)fffff](#속성의-명명namingfffff)\
　 [관계](#관계)\
　　　 [가. 관계의 정의](#가-관계의-정의)\
　　　 [나. 관계의 패어링](#나-관계의-패어링)\
　　 [관계의 분류](#관계의-분류)\
　　 [관계의 표기법](#관계의-표기법)\
　　　 [가. 관계명(Membership)](#가-관계명membership)\
　　　 [나. 관계차수(Degree/Cardinality)](#나-관계차수degreecardinality)\
　　　 [다. 관계선택사양(Optionality)](#다-관계선택사양optionality)\
　　 [관계의 정의 및 읽는 방법](#관계의-정의-및-읽는-방법)\
　　　 [가. 관계 체크사항](#가-관계-체크사항)\
　　　 [나. 관계 읽기](#나-관계-읽기)\
　 [식별자](#식별자)\
　　 [식별자의 특징](#식별자의-특징)\
　　 [식별자 분류 및 표기법](#식별자-분류-및-표기법)\
　　　 [가. 식별자 분류](#가-식별자-분류)\
　　　 [나. 식별자 표기법](#나-식별자-표기법)\
　　 [주식별자 도출기준](#주식별자-도출기준)\
　　　 [가. 해당 업무에서 자주 이용되는 속성을 주식별자로 지정하도록 함](#가-해당-업무에서-자주-이용되는-속성을-주식별자로-지정하도록-함)\
　　　 [나. 명칭, 내역 등과 같이 이름으로 기술되는 것은 피함](#나-명칭-내역-등과-같이-이름으로-기술되는-것은-피함)\
　　　 [다. 속성의 수가 많아지지 않도록 함](#다-속성의-수가-많아지지-않도록-함)\
　　 [식별자관계와 비식별자관계에 따른 식별자](#식별자관계와-비식별자관계에-따른-식별자)\
　　　 [가. 식별자관계와 비식별자 관계의 결정](#가-식별자관계와-비식별자-관계의-결정)\
　　　 [나. 식별자관계](#나-식별자관계)\
　　　 [다. 비식별자관계](#다-비식별자관계)\
　　　 [라. 식별자 관계로만 설정할 경우의 문제점](#라-식별자-관계로만-설정할-경우의-문제점)\
　　　 [마](#마)\
　　　 [비식별자 관계로만 설정할 경우의](#비식별자-관계로만-설정할-경우의)\
　　　 [문제점](#문제점)\
　　　 [바](#바)\
　　　 [식별자관계와](#식별자관계와)\
　　　 [비식별자관계](#비식별자관계)\
　　　 [모델링](#모델링)\
　 [데이터 모델의 이해](#데이터-모델의-이해)\
　　　 [가. 모델링의 정의](#가-모델링의-정의)\
　　　 [다. 모델링의 세 가지 관점](#다-모델링의-세-가지-관점)\
　　 [데이터 모델의 기본 개념의 이해](#데이터-모델의-기본-개념의-이해)\
　　　 [가. 모델링의 정의](#가-모델링의-정의)\
　　　 [나. 데이터 모델이 제공하는 기능](#나-데이터-모델이-제공하는-기능)\
　　 [데이터 모델링의 중요성 및 유의점](#데이터-모델링의-중요성-및-유의점)\
　　　 [가. 파급효과(Leverage)](#가-파급효과leverage)\
　　　 [복잡한 정보 요구사항의 간결한 표현(Conciseness)](#복잡한-정보-요구사항의-간결한-표현conciseness)\
　　　 [다. 데이터 품질(Data Quality)](#다-데이터-품질data-quality)\
　　 [데이터 모델링의 3단계 진행](#데이터-모델링의-3단계-진행)\
　　　 [가. 개념적 데이터](#가-개념적-데이터)\
　　　 [모델링(Conceptual Data Modeling)](#모델링conceptual-data-modeling)\
　　　 [나. 논리적 데이터](#나-논리적-데이터)\
　　　 [모델링(Logical Data Modeling)](#모델링logical-data-modeling)\
　　　 [다. 물리적 데이터](#다-물리적-데이터)\
　　　 [모델링(Physical Data Modeling)](#모델링physical-data-modeling)\
　　 [프로젝트 생명주기(Life Cycle)에서 데이터 모델링](#프로젝트-생명주기life-cycle에서-데이터-모델링)\
　　 [데이터 모델링에서 데이터독립성의 이해](#데이터-모델링에서-데이터독립성의-이해)\
　　　 [가](#가)\
　　　 [데이터독립성의 필요성](#데이터독립성의-필요성)\
　　　 [나. 데이터베이스 3단계 구조](#나-데이터베이스-3단계-구조)\
　　　 [다. 데이터독립성 요소](#다-데이터독립성-요소)\
　　　 [라. 두](#라-두)\
　　　 [영역의](#영역의)\
　　　 [데이터독립성](#데이터독립성)\
](#)\
　　　 [마. 사상(Mapping)](#마-사상mapping)\
　　 [데이터 모델링의 중요한 세 가지 개념](#데이터-모델링의-중요한-세-가지-개념)\
　　　 [가. 데이터 모델링의 세 가지 요소](#가-데이터-모델링의-세-가지-요소)\
　　　 [나. 단수와 집합(복수)의 명명](#나-단수와-집합복수의-명명)\
　　 [데이터 모델링의 이해관계자](#데이터-모델링의-이해관계자)\
　　　 [가. 이해관계자의 데이터 모델링 중요성 인식](#가-이해관계자의-데이터-모델링-중요성-인식)\
　　　 [나. 데이터 모델링의 이해관계자](#나-데이터-모델링의-이해관계자)\
　　 [데이터 모델의 표기법인 ERD의 이해](#데이터-모델의-표기법인-erd의-이해)\
　　　 [가. 데이터 모델 표기법](#가-데이터-모델-표기법)\
　　　 [나. ERD(Entity Relationship Diagram) 표기법을 이용하여 모델링하는 방법](#나-erdentity-relationship-diagram-표기법을-이용하여-모델링하는-방법)\
　　 [좋은 데이터 모델의 요소](#좋은-데이터-모델의-요소)\
　　　 [가. 완전성(Completeness)](#가-완전성completeness)\
　　　 [나. 중복배제(Non-Redundancy)](#나-중복배제non-redundancy)\
　　　 [다](#다)\
　　　 [업무규칙(Business Rules)](#업무규칙business-rules)\
　　　 [라. 데이터 재사용(Data Reusability)](#라-데이터-재사용data-reusability)\
　　　 [마. 의사소통(Communication)](#마-의사소통communication)\
　　　 [바. 통합성(Integration)](#바-통합성integration)\
　 [성능 데이터 모델링의 개요](#성능-데이터-모델링의-개요)\
　　 [성능 데이터 모델링 수행시점](#성능-데이터-모델링-수행시점)\
　　 [성능 데이터 모델링 고려사항](#성능-데이터-모델링-고려사항)\
　 [정규화와 성능](#정규화와-성능)\
　　 [반정규화된 테이블의 성능저하 사례1](#반정규화된-테이블의-성능저하-사례1)\
　　 [반정규화된 테이블의 성능저하 사례2](#반정규화된-테이블의-성능저하-사례2)\
　　 [반정규화된 테이블의 성능저하 사례3](#반정규화된-테이블의-성능저하-사례3)\
　　 [반정규화된 테이블의 성능저하 사례4](#반정규화된-테이블의-성능저하-사례4)\
　　 [함수적 종속성(Functional Dependency)에 근거한 정규화 수행 필요](#함수적-종속성functional-dependency에-근거한-정규화-수행-필요)\
　 [반정규화와 성능](#반정규화와-성능)\
　　　 [가. 반정규화의 정의](#가-반정규화의-정의)\
　　　 [나. 반정규화의 적용방법](#나-반정규화의-적용방법)\
　　 [반정규화의 기법](#반정규화의-기법)\
　　　 [가. 테이블 반정규화](#가-테이블-반정규화)\
　　　 [나. 칼럼 반정규화](#나-칼럼-반정규화)\
　　　 [다. 관계 반정규화](#다-관계-반정규화)\
　　 [정규화가 잘 정의된 데이터 모델에서 성능이 저하될 수 있는 경우](#정규화가-잘-정의된-데이터-모델에서-성능이-저하될-수-있는-경우)\
　　 [정규화가 잘 정의된 데이터 모델에서 성능이 저하된 경우](#정규화가-잘-정의된-데이터-모델에서-성능이-저하된-경우)\
　 [대량 데이터에 따른 성능](#대량-데이터에-따른-성능)\
　　 [한 테이블에 많은 수의 칼럼을 가지고 있는 경우](#한-테이블에-많은-수의-칼럼을-가지고-있는-경우)\
　　 [대량 데이터 저장 및 처리로 인해 성능](#대량-데이터-저장-및-처리로-인해-성능)\
　　　 [가. RANGE PARTITION 적용](#가-range-partition-적용)\
　　　 [나. LIST PARTITION 적용](#나-list-partition-적용)\
　　　 [다. HASH PARTITION 적용](#다-hash-partition-적용)\
　　 [테이블에 대한 수평분할/수직분할의 절차](#테이블에-대한-수평분할수직분할의-절차)\
　 [데이터베이스 구조와 성능](#데이터베이스-구조와-성능)\
　　　 [가. 슈퍼/서브타입 데이터 모델의 개요](#가-슈퍼서브타입-데이터-모델의-개요)\
　　　 [나. 슈퍼/서브타입 데이터 모델의 변환](#나-슈퍼서브타입-데이터-모델의-변환)\
　　　 [다. 슈퍼/서브 타입 데이터 모델의 변환기술](#다-슈퍼서브-타입-데이터-모델의-변환기술)\
　　　 [라. 슈퍼/서브타입 데이터 모델의 변환타입 비교](#라-슈퍼서브타입-데이터-모델의-변환타입-비교)\
　　 [인덱스 특성을 고려한 PK/FK 데이터베이스 성능향상](#인덱스-특성을-고려한-pkfk-데이터베이스-성능향상)\
　　　 [가. PK/FK 칼럼 순서와 성능개요](#가-pkfk-칼럼-순서와-성능개요)\
　　　 [나. PK칼럼의 순서를 조정하지 않으면 성능이 저하 이유](#나-pk칼럼의-순서를-조정하지-않으면-성능이-저하-이유)\
　　　 [다. PK순서를 잘못 지정하여 성능이 저하된 경우 - 간단한 오류](#다-pk순서를-잘못-지정하여-성능이-저하된-경우---간단한-오류)\
　　　 [라. PK순서를 잘못 지정하여 성능이 저하된 경우 - 복잡한 오류](#라-pk순서를-잘못-지정하여-성능이-저하된-경우---복잡한-오류)\
　　 [물리적인 테이블에 FK제약이 걸려있지 않을 경우 인덱스 미생성으로 성능저하](#물리적인-테이블에-fk제약이-걸려있지-않을-경우-인덱스-미생성으로-성능저하)\
　 [분산 데이터베이스와 성능](#분산-데이터베이스와-성능)\
　　 [분산 데이터베이스의 투명성(Transparency)](#분산-데이터베이스의-투명성transparency)\
　　 [분산 데이터베이스의 적용 방법 및 장단점](#분산-데이터베이스의-적용-방법-및-장단점)\
　　　 [가. 분산 데이터베이스 적용방법](#가-분산-데이터베이스-적용방법)\
　　　 [나. 분산 데이터베이스 장단점](#나-분산-데이터베이스-장단점)\
　　 [분산 데이터베이스의 활용 방향성](#분산-데이터베이스의-활용-방향성)\
　　 [데이터베이스 분산구성의 가치](#데이터베이스-분산구성의-가치)\
　　 [분산 데이터베이스의 적용 기법](#분산-데이터베이스의-적용-기법)\
　　　 [가. 테이블 위치 분산](#가-테이블-위치-분산)\
　　　 [나. 테이블 분할(Fragmentation) 분산](#나-테이블-분할fragmentation-분산)\
　　　 [다. 테이블 복제(Replication) 분산](#다-테이블-복제replication-분산)\
　　　 [라. 테이블 요약(Summarization) 분산](#라-테이블-요약summarization-분산)\
　　 [분산 데이터베이스를 적용하여 성능이 향상된 사례](#분산-데이터베이스를-적용하여-성능이-향상된-사례)\
　 [관계형 데이터베이스 개요](#관계형-데이터베이스-개요)\
　　 [SQL(Structured Query Language)](#sqlstructured-query-language)\
　　 [TABLE](#table)\
　　 [ERD(Entity Relationship Diagram)](#erdentity-relationship-diagram)\
　 [DDL](#ddl)\
　　 [CREATE TABLE](#create-table)\
　　　 [가. 테이블과 칼럼 정의](#가-테이블과-칼럼-정의)\
　　　 [나. CREATE TABLE](#나-create-table)\
　　　 [다. 제약조건(CONSTRAINT)](#다-제약조건constraint)\
　　　 [라. 생성된 테이블 구조 확인](#라-생성된-테이블-구조-확인)\
　　　 [마](#마)\
　　　 [SELECT 문장을 통한 테이블 생성](#select-문장을-통한-테이블-생성)\
　　　 [사례](#사례)\
　　　 [가. ADD COLUMN](#가-add-column)\
　　　 [나. DROP COLUMN\](#나-drop-column)\
　　　 [다. MODIFY COLUMN](#다-modify-column)\
　　　 [라. DROP CONSTRAINT](#라-drop-constraint)\
　　　 [마. ADD](#마-add)\
](#)\
　　 [DROP TABLE](#drop-table)\
　　 [TRUNCATE TABLE](#truncate-table)\
　 [DML](#dml)\
　　 [UPDATE](#update)\
　　 [DELETE](#delete)\
　　 [SELECT](#select)\
　 [TCL](#tcl)\
　　 [COMMIT](#commit)\
　 [WHERE 절](#where-절)\
　　 [연산자의 종류](#연산자의-종류)\
　　 [SQL 연산자](#sql-연산자)\
　　 [부정 연산자](#부정-연산자)\
　　 [ROWNUM, TOP 사용](#rownum-top-사용)\
　 [함수(FUNCTION)](#함수function)\
　　 [날짜형 함수](#날짜형-함수)\
　　 [변환형 함수](#변환형-함수)\
　　 [CASE 표현](#case-표현)\
　　 [NULL 관련 함수](#null-관련-함수)\
　　　 [가. NVL/ISNULL 함수](#가-nvlisnull-함수)\
　　　 [나. NULL과 공집합](#나-null과-공집합)\
　　　 [다. NULLIF](#다-nullif)\
　　　 [라. 기타 NULL 관련 함수 (COALESCE)](#라-기타-null-관련-함수-coalesce)\
　 [GROUP BY, HAVING 절](#group-by-having-절)\
　　 [CASE 표현을 활용한 월별 데이터 집계](#case-표현을-활용한-월별-데이터-집계)\
　　 [집계 함수와 NULL](#집계-함수와-null)\
　　 [3. Top N 쿼리](#3-top-n-쿼리)\
　 [조인(JOIN)](#조인join)\
　　 [EQUI JOIN](#equi-join)\
　　 [Non EQUI JOIN](#non-equi-join)\
　　 [3개 이상 TABLE JOIN](#3개-이상-table-join)\
　 [표준 조인](#표준-조인)\
　　 [1. STANDARD SQL 개요](#1-standard-sql-개요)\
　　　 [가. 일반 집합 연산자](#가-일반-집합-연산자)\
　　　 [나. 순수 관계 연산자](#나-순수-관계-연산자)\
　　 [INNER JOIN](#inner-join)\
　　 [NATURAL JOIN](#natural-join)\
　　 [USING 조건절](#using-조건절)\
　　 [ON 조건절](#on-조건절)\
　　　 [가. WHERE 절과의 혼용](#가-where-절과의-혼용)\
　　　 [나. ON 조건절 + 데이터 검증 조건 추가](#나-on-조건절--데이터-검증-조건-추가)\
　　　 [다. ON 조건절 예제](#다-on-조건절-예제)\
　　　 [라. 다중 테이블 JOIN](#라-다중-테이블-join)\
　　 [CROSS JOIN](#cross-join)\
　　 [OUTER JOIN](#outer-join)\
　　　 [가](#가)\
　　　 [나. RIGHT OUTER JOIN](#나-right-outer-join)\
　　　 [다. FULL OUTER JOIN](#다-full-outer-join)\
　　 [INNER vs OUTER vs CROSS JOIN 비교](#inner-vs-outer-vs-cross-join-비교)\
　 [집합 연산자](#집합-연산자)\
　　 [1. 계층형 질의](#1-계층형-질의)\
　　　 [가. Oracle 계층형 질의](#가-oracle-계층형-질의)\
　　　 [나. SQL Server 계층형 질의](#나-sql-server-계층형-질의)\
　　 [셀프 조인](#셀프-조인)\
　 [서브쿼리](#서브쿼리)\
　　 [1. 단일 행 서브 쿼리](#1-단일-행-서브-쿼리)\
　　 [12. 다중 행 서브쿼리](#12-다중-행-서브쿼리)\
　　 [연관 서브쿼리](#연관-서브쿼리)\
　　 [그밖에 위치에서 사용하는 서브쿼리](#그밖에-위치에서-사용하는-서브쿼리)\
　　　 [가. SELECT 절에 서브쿼리 사용하기](#가-select-절에-서브쿼리-사용하기)\
　　　 [나. FROM 절에서 서브쿼리 사용하기](#나-from-절에서-서브쿼리-사용하기)\
　　　 [다. HAVING 절에서 서브쿼리 사용하기](#다-having-절에서-서브쿼리-사용하기)\
　　　 [라. UPDATE문의 SET 절에서 사용하기](#라-update문의-set-절에서-사용하기)\
　　　 [마](#마)\
　　　 [VALUES절에서 사용하기](#values절에서-사용하기)\
　　 [뷰(View)](#뷰view)\
　 [그룹 함수](#그룹-함수)\
　　 [GROUPING SETS 함수](#grouping-sets-함수)\
　 [윈도우 함수](#윈도우-함수)\
　　　 [가. RANK 함수](#가-rank-함수)\
　　　 [나](#나)\
　　　 [다](#다)\
　　 [일반 집계 함수](#일반-집계-함수)\
　　　 [가. SUM 함수](#가-sum-함수)\
　　　 [나. MAX 함수](#나-max-함수)\
　　　 [다. MIN 함수](#다-min-함수)\
　　　 [라. AVG 함수](#라-avg-함수)\
　　　 [마](#마)\
　　 [그룹 내 행 순서 함수](#그룹-내-행-순서-함수)\
　　　 [가](#가)\
　　　 [나](#나)\
　　　 [다. LAG 함수](#다-lag-함수)\
　　　 [라. LEAD 함수](#라-lead-함수)\
　　 [그룹 내 비율 함수](#그룹-내-비율-함수)\
　　　 [가](#가)\
　　　 [나](#나)\
　　　 [다. CUME_DIST 함수](#다-cume_dist-함수)\
　　　 [라. NTILE 함수](#라-ntile-함수)\
　 [DCL](#dcl)\
　　 [유저와 권한](#유저와-권한)\
　　　 [가. 유저 생성과 시스템 권한 부여](#가-유저-생성과-시스템-권한-부여)\
　　　 [나. OBJECT에 대한 권한 부여](#나-object에-대한-권한-부여)\
　　 [Role을 이용한 권한 부여](#role을-이용한-권한-부여)\
　 [절차형 SQL](#절차형-sql)\
　　 [PL/SQL 개요](#plsql-개요)\
　　　 [가. PL/SQL 특징](#가-plsql-특징)\
　　　 [나. PL/SQL 구조](#나-plsql-구조)\
　　　 [다. PL/SQL 기본 문법(Syntax)](#다-plsql-기본-문법syntax)\
　　　 [가. T-SQL 특징](#가-t-sql-특징)\
　　　 [나. T-SQL 구조](#나-t-sql-구조)\
　　　 [다. T-SQL 기본 문법(Syntax)](#다-t-sql-기본-문법syntax)\
　　 [User Defined Function의 생성과 활용](#user-defined-function의-생성과-활용)\
　　 [프로시저와 트리거의 차이점](#프로시저와-트리거의-차이점)\
　 [옵티마이저와 실행계획](#옵티마이저와-실행계획)\
　　　 [가. 규칙기반 옵티마이저](#가-규칙기반-옵티마이저)\
　　　 [나. 비용기반 옵티마이저](#나-비용기반-옵티마이저)\
　　 [실행계획](#실행계획)\
　　 [SQL 처리 흐름도](#sql-처리-흐름도)\
　 [인덱스 기본](#인덱스-기본)\
　　　 [가. 트리 기반 인덱스](#가-트리-기반-인덱스)\
　　　 [나. SQL Server의 클러스터형 인덱스](#나-sql-server의-클러스터형-인덱스)\
　　 [전체 테이블 스캔과 인덱스 스캔](#전체-테이블-스캔과-인덱스-스캔)\
　　　 [가. 전체 테이블 스캔](#가-전체-테이블-스캔)\
　　　 [나. 인덱스 스캔](#나-인덱스-스캔)\
　　　 [다. 전체 테이블 스캔과 인덱스 스캔 방식의 비교](#다-전체-테이블-스캔과-인덱스-스캔-방식의-비교)\
　　　 [가. 규칙기반 옵티마이저](#가-규칙기반-옵티마이저)\
　 [조인 수행 원리](#조인-수행-원리)\
　　 [Sort Merge Join](#sort-merge-join)\
　　 [Hash Join](#hash-join)\
　 [데이터베이스 아키텍처](#데이터베이스-아키텍처)\
　　　 [가. 모델링의 정의](#가-모델링의-정의)\
　　　 [나. SQL Server 아키텍처](#나-sql-server-아키텍처)\
　　 [프로세스](#프로세스)\
　　　 [가. 서버](#가-서버)\
　　　 [프로세스(Server Processes)](#프로세스server-processes)\
　　　 [나. 백그라운드 프로세스(Background Processes)](#나-백그라운드-프로세스background-processes)\
　　 [파일 구조](#파일-구조)\
　　　 [가. 데이터 파일](#가-데이터-파일)\
　　　 [나. 임시 데이터 파일](#나-임시-데이터-파일)\
　　　 [다. 로그 파일](#다-로그-파일)\
　　 [메모리 구조](#메모리-구조)\
　　　 [가. DB 버퍼 캐시(DB Buffer Cache)](#가-db-버퍼-캐시db-buffer-cache)\
　　　 [나. 공유 풀(Shared Pool)](#나-공유-풀shared-pool)\
　　　 [다. 로그 버퍼(Log Buffer)](#다-로그-버퍼log-buffer)\
　　　 [라. PGA(Process Global Area)](#라-pgaprocess-global-area)\
　　 [대기 이벤트](#대기-이벤트)\
　　　 [가. 라이브러리 캐시 부하](#가-라이브러리-캐시-부하)\
　　　 [나. 데이터베이스 Call과 네트워크 부하](#나-데이터베이스-call과-네트워크-부하)\
　　　 [다. 디스크 I/O 부하](#다-디스크-io-부하)\
　　　 [라. 버퍼 캐시 경합](#라-버퍼-캐시-경합)\
　　　 [마](#마)\
　　　 [대기](#대기)\
　　　 [이벤트](#이벤트)\
　 [SQL 파싱 부하](#sql-파싱-부하)\
　　 [2. 데이터 모델의 기본 개념의 이해](#2-데이터-모델의-기본-개념의-이해)\
　　　 [가. SQL 파싱(Parsing)](#가-sql-파싱parsing)\
　　　 [나. SQL 최적화(Optimization)](#나-sql-최적화optimization)\
　　 [캐싱된 SQL 공유](#캐싱된-sql-공유)\
　　　 [가. 실행계획 공유 조건](#가-실행계획-공유-조건)\
　　　 [나. 실행계획을 공유하지 못하는 경우](#나-실행계획을-공유하지-못하는-경우)\
　　 [바인드 변수 사용하기](#바인드-변수-사용하기)\
　　　 [가. 바인드 변수의 중요성](#가-바인드-변수의-중요성)\
　　　 [나. 바인드 변수 사용 시 주의사항](#나-바인드-변수-사용-시-주의사항)\
　　　 [다. 바인드 변수 부작용을 극복하기 위한 노력](#다-바인드-변수-부작용을-극복하기-위한-노력)\
　　 [Static SQL과 Dynamic SQL](#static-sql과-dynamic-sql)\
　　　 [가. Static SQL](#가-static-sql)\
　　　 [나. Dynamic SQL](#나-dynamic-sql)\
　　　 [다. 바인드 변수의 중요성 재강조](#다-바인드-변수의-중요성-재강조)\
　　 [애플리케이션 커서 캐싱](#애플리케이션-커서-캐싱)\
　 [데이터베이스 Call과 네트워크 부하](#데이터베이스-call과-네트워크-부하)\
　　　 [가. SQL 커서에 대한 작업 요청에 따른 구분](#가-sql-커서에-대한-작업-요청에-따른-구분)\
　　　 [나. Call 발생 위치에 따른 구분](#나-call-발생-위치에-따른-구분)\
　　 [데이터베이스 Call과 성능](#데이터베이스-call과-성능)\
　　　 [가. One SQL 구현의 중요성](#가-one-sql-구현의-중요성)\
　　　 [나. 데이터베이스 Call과 시스템 확장성](#나-데이터베이스-call과-시스템-확장성)\
　　 [Array Processing 활용](#array-processing-활용)\
　　 [Fetch Call 최소화](#fetch-call-최소화)\
　　　 [가. 부분범위처리 원리](#가-부분범위처리-원리)\
　　　 [나. ArraySize 조정에 의한 Fetch Call 감소 및](#나-arraysize-조정에-의한-fetch-call-감소-및)\
　　　 [블록](#블록)\
　　　 [감소 효과](#감소-효과)\
　　 [페이지 처리 활용](#페이지-처리-활용)\
　　 [분산 쿼리](#분산-쿼리)\
　　 [사용자 정의 함수/프로시저의 특징과 성능](#사용자-정의-함수프로시저의-특징과-성능)\
　　　 [가. 사용자 정의](#가-사용자-정의)\
　　　 [함수/프로시저의 특징](#함수프로시저의-특징)\
　　　 [나. 사용자 정의](#나-사용자-정의)\
　　　 [함수/프로시저에 의한 성능 저하 해소 방안](#함수프로시저에-의한-성능-저하-해소-방안)\
　　 [4. 데이터 모델링의 3단계 진행](#4-데이터-모델링의-3단계-진행)\
　　 [메모리 I/O vs. 디스크I/O](#메모리-io-vs-디스크io)\
　　　 [가. I/O 효율화 튜닝의 중요성](#가-io-효율화-튜닝의-중요성)\
　　　 [나. 버퍼 캐시 히트율(Buffer Cache Hit Ratio)](#나-버퍼-캐시-히트율buffer-cache-hit-ratio)\
　　　 [다. 네트워크, 파일시스템 캐시가 I/O 효율에 미치는 영향](#다-네트워크-파일시스템-캐시가-io-효율에-미치는-영향)\
　　 [Sequential I/O vs. Random I/O](#sequential-io-vs-random-io)\
　　　 [가. Sequential 액세스에 의한 선택 비중 높이기](#가-sequential-액세스에-의한-선택-비중-높이기)\
　　　 [나. Random 액세스 발생량 줄이기](#나-random-액세스-발생량-줄이기)\
　　 [Single Block I/O vs. MultiBlock I/O](#single-block-io-vs-multiblock-io)\
　　 [I/O 효율화 원리](#io-효율화-원리)\
　　　 [록만](#록만)\
　　　 [읽도록 SQL 작성](#읽도록-sql-작성)\
　　　 [나. 최적의 옵티마이징 팩터 제공](#나-최적의-옵티마이징-팩터-제공)\
　　　 [다. 필요하다면, 옵티마이저 힌트를 사용해 최적의 액세스 경로로 유도](#다-필요하다면-옵티마이저-힌트를-사용해-최적의-액세스-경로로-유도)\
　 [Lock](#lock)\
　　　 [가. Lock이란?](#가-lock이란)\
　　　 [나. 공유 Lock과 배타적 Lock](#나-공유-lock과-배타적-lock)\
　　　 [다. 블로킹과 교착상태](#다-블로킹과-교착상태)\
　　 [SQL Server Lock](#sql-server-lock)\
　　　 [가. Lock 종류](#가-lock-종류)\
　　　 [나. Lock 레벨과 Escalation](#나-lock-레벨과-escalation)\
　　　 [다. Lock 호환성](#다-lock-호환성)\
　　 [Oracle Lock](#oracle-lock)\
　　　 [가. 로우 Lock](#가-로우-lock)\
　　　 [나. 테이블 Lock](#나-테이블-lock)\
　 [트랜잭션](#트랜잭션)\
　　 [트랜잭션 격리성](#트랜잭션-격리성)\
　　　 [가. 낮은 단계의 격리성 수준에서 발생할 수 있는 현상들](#가-낮은-단계의-격리성-수준에서-발생할-수-있는-현상들)\
　　　 [나. 트랜잭션 격리성 수준](#나-트랜잭션-격리성-수준)\
　 [동시성 제어](#동시성-제어)\
　　　 [가. 비관적 동시성 제어](#가-비관적-동시성-제어)\
　　　 [나. 낙관적 동시성 제어](#나-낙관적-동시성-제어)\
　　 [다중버전 동시성 제어](#다중버전-동시성-제어)\
　　　 [가. 일반적인 Locking 메커니즘의 문제점](#가-일반적인-locking-메커니즘의-문제점)\
　　　 [나. 다중버전 동시성 제어](#나-다중버전-동시성-제어)\
　　　 [다. 문장수준 읽기 일관성](#다-문장수준-읽기-일관성)\
　　　 [라. 트랜잭션 수준 읽기](#라-트랜잭션-수준-읽기)\
　　　 [마. Snapshot too old](#마-snapshot-too-old)\
　 [옵티마이저](#옵티마이저)\
　　　 [가. 옵티마이저란?](#가-옵티마이저란)\
　　　 [나. 옵티마이저 종류](#나-옵티마이저-종류)\
　　　 [다. SQL 최적화 과정](#다-sql-최적화-과정)\
　　　 [라. 최적화 목표](#라-최적화-목표)\
　　 [옵티마이저 행동에 영향을 미치는 요소](#옵티마이저-행동에-영향을-미치는-요소)\
　　　 [가. SQL과 연산자 형태](#가-sql과-연산자-형태)\
　　　 [나. 옵티마이징 팩터](#나-옵티마이징-팩터)\
　　　 [다. DBMS 제약 설정](#다-dbms-제약-설정)\
　　　 [라. 옵티마이저 힌트](#라-옵티마이저-힌트)\
　　　 [마. 통계정보](#마-통계정보)\
　　　 [바. 옵티마이저](#바-옵티마이저)\
　　　 [관련](#관련)\
　　　 [파라미터](#파라미터)\
](#)\
　　　 [사. DBMS 버전과 종류](#사-dbms-버전과-종류)\
　　 [옵티마이저의 한계](#옵티마이저의-한계)\
　　　 [가. 옵티마이징 팩터의 부족](#가-옵티마이징-팩터의-부족)\
　　　 [나. 통계정보의 부정확성](#나-통계정보의-부정확성)\
　　　 [다. 바인드 변수 사용 시 균등분포 가정](#다-바인드-변수-사용-시-균등분포-가정)\
　　　 [라. 비현실적인 가정](#라-비현실적인-가정)\
　　　 [마. 규칙에](#마-규칙에)\
　　　 [의존하는](#의존하는)\
　　　 [바. 하드웨어](#바-하드웨어)\
　　　 [성능](#성능)\
　　 [통계정보를 이용한 비용계산 원리](#통계정보를-이용한-비용계산-원리)\
　　　 [가. 선택도](#가-선택도)\
![IMAGE](index_files/Image_589.jpg)](#mageindex_filesimage_589jpg)\
　　　 [나. 카디널리티](#나-카디널리티)\
　　　 [다. 히스토그램](#다-히스토그램)\
　　　 [라. 비용](#라-비용)\
　　 [옵티마이저](#옵티마이저)\
　　　 [가. Oracle 힌트](#가-oracle-힌트)\
　　　 [나. SQL Server 힌트](#나-sql-server-힌트)\
　 [쿼리변환](#쿼리변환)\
　　 [서브쿼리 Unnesting](#서브쿼리-unnesting)\
　　 [뷰 Merging](#뷰-merging)\
　　 [조건절 Pushing](#조건절-pushing)\
　　　 [가. 조건절(Predicate) Pushdown](#가-조건절predicate-pushdown)\
　　　 [나. 조건절(Predicate) Pullup](#나-조건절predicate-pullup)\
　　　 [다. 조인 조건(Join Predicate) Pushdown](#다-조인-조건join-predicate-pushdown)\
　　 [조건절 이행](#조건절-이행)\
　　 [불필요한 조인 제거](#불필요한-조인-제거)\
　　 [OR 조건을 Union으로 변환](#or-조건을-union으로-변환)\
　　 [기타 쿼리 변환](#기타-쿼리-변환)\
　　　 [가. 집합 연산을 조인으로 변환](#가-집합-연산을-조인으로-변환)\
　　　 [나. 조인 칼럼에 IS NOT NULL 조건 추가](#나-조인-칼럼에-is-not-null-조건-추가)\
　　　 [다. 필터 조건 추가](#다-필터-조건-추가)\
　　　 [라. 조건절 비교 순서](#라-조건절-비교-순서)\
　 [인덱스 기본 원리](#인덱스-기본-원리)\
　　　 [가. 인덱스 기본](#가-인덱스-기본)\
　　　 [나. 인덱스 탐색](#나-인덱스-탐색)\
　　 [다양한 인덱스 스캔 방식](#다양한-인덱스-스캔-방식)\
　　　 [가. Index Range Scan](#가-index-range-scan)\
　　　 [나. Index Full Scan](#나-index-full-scan)\
　　　 [다. Index Unique Scan](#다-index-unique-scan)\
　　　 [라. Index Skip Scan](#라-index-skip-scan)\
　　　 [마. Index Fast Full Scan](#마-index-fast-full-scan)\
　　　 [바. Index Range Scan Descending](#바-index-range-scan-descending)\
　　 [인덱스 종류](#인덱스-종류)\
　　　 [가. B*Tree 인덱스](#가-btree-인덱스)\
　　　 [나](#나)\
　　　 [비<span color: black; font-family:바탕, serif; font-style: normal; font-weight: normal; text-decoration: underline; font-size: 8.">트맵](#비span-color-black-font-family바탕-serif-font-style-normal-font-weight-normal-text-decoration-underline-font-size-8트맵)\
　　　 [인덱스](#인덱스)\
　　　 [다. 함수기반 인덱스](#다-함수기반-인덱스)\
　　　 [라. 리버스 키 인덱스](#라-리버스-키-인덱스)\
　　　 [마. 클러스터](#마-클러스터)\
　　　 [인덱스](#인덱스)\
](#)\
　　　 [바. 클러스터형](#바-클러스터형)\
　　　 [인덱스/IOT](#인덱스iot)\
](#)\
　 [인덱스 튜닝](#인덱스-튜닝)\
　　　 [가. 범위 스캔이 불가능하거나 인덱스 사용이 아예 불가능한 경우](#가-범위-스캔이-불가능하거나-인덱스-사용이-아예-불가능한-경우)\
　　　 [나. 인덱스 칼럼의 가공](#나-인덱스-칼럼의-가공)\
　　　 [다. 묵시적 형변환](#다-묵시적-형변환)\
　　 [테이블 Random 액세스 최소화](#테이블-random-액세스-최소화)\
　　　 [가. 인덱스 ROWID에 의한 테이블 Random 액세스](#가-인덱스-rowid에-의한-테이블-random-액세스)\
　　　 [나. 인덱스 손익분기점](#나-인덱스-손익분기점)\
　　　 [다. 테이블 Random 액세스 최소화 튜닝](#다-테이블-random-액세스-최소화-튜닝)\
　　 [인덱스 스캔범위 최소화](#인덱스-스캔범위-최소화)\
　　　 [가. 인덱스 선행 칼럼이 범위조건일 때의 비효율](#가-인덱스-선행-칼럼이-범위조건일-때의-비효율)\
　　　 [나. 범위조건을 In-List로 전환](#나-범위조건을-in-list로-전환)\
　　　 [다. 범위조건을 2개 이상 사용할 때의 비효율](#다-범위조건을-2개-이상-사용할-때의-비효율)\
　　 [인덱스 설계](#인덱스-설계)\
　　　 [가. 결합 인덱스 구성을 위한 기본 공식](#가-결합-인덱스-구성을-위한-기본-공식)\
　　　 [나. 추가적인 고려사항](#나-추가적인-고려사항)\
　　　 [다. 인덱스 설계도 작성](#다-인덱스-설계도-작성)\
　 [조인 기본 원리](#조인-기본-원리)\
　　 [1. Nested Loop Join](#1-nested-loop-join)\
　　　 [가. 기본 메커니즘](#가-기본-메커니즘)\
　　　 [나. NL Join 수행 과정 분석](#나-nl-join-수행-과정-분석)\
　　　 [다. NL Join의 특징](#다-nl-join의-특징)\
　　 [Sort Merge Join](#sort-merge-join)\
　　　 [가. 기본 메커니즘](#가-기본-메커니즘)\
　　　 [나. Sort Merge Join의 특징](#나-sort-merge-join의-특징)\
　　 [Hash Join](#hash-join)\
　　　 [가. 기본 메커니즘](#가-기본-메커니즘)\
　　　 [나. Build Input이 가용 메모리 공간을 초과할 때 처리 방식](#나-build-input이-가용-메모리-공간을-초과할-때-처리-방식)\
　　　 [다. Build Input 해시 키 값에 중복이 많을 때 발생하는 비효율](#다-build-input-해시-키-값에-중복이-많을-때-발생하는-비효율)\
　　　 [라. Hash Join 사용기준](#라-hash-join-사용기준)\
　　 [Scalar Subquery](#scalar-subquery)\
　　　 [가. Scalar Subquery의 캐싱 효과](#가-scalar-subquery의-캐싱-효과)\
　 [고급 조인 기법](#고급-조인-기법)\
　　 [배타적 관계의 조인](#배타적-관계의-조인)\
　　 [부등호 조인](#부등호-조인)\
　　 [Between 조인](#between-조인)\
　　　 [가. 선분이력이란?](#가-선분이력이란)\
　　　 [나. 선분이력 기본 조회 패턴](#나-선분이력-기본-조회-패턴)\
　　　 [다. 선분이력 조인](#다-선분이력-조인)\
　　　 [라. Between 조인](#라-between-조인)\
　　 [ROWID 활용](#rowid-활용)\
　 [고급 SQL 활용](#고급-sql-활용)\
　　 [데이터 복제 기법 활용](#데이터-복제-기법-활용)\
　　 [Union All을 활용한 M:M 관계의 조인](#union-all을-활용한-mm-관계의-조인)\
　　 [페이징 처리](#페이징-처리)\
　　　 [가. 일반적인 페이징 처리용 SQL](#가-일반적인-페이징-처리용-sql)\
　　　 [나. 뒤쪽 페이지까지 자주 조회할 때](#나-뒤쪽-페이지까지-자주-조회할-때)\
　　　 [다. Union All 활용](#다-union-all-활용)\
　　 [윈도우 함수 활용](#윈도우-함수-활용)\
　　 [With 구문 활용](#with-구문-활용)\
　 [소트 튜닝](#소트-튜닝)\
　　　 [가. 메모리 소트와 디스크 소트](#가-메모리-소트와-디스크-소트)\
　　　 [나. 소트를 발생시키는 오퍼레이션](#나-소트를-발생시키는-오퍼레이션)\
　　　 [다. 소트 튜닝 요약](#다-소트-튜닝-요약)\
　　 [데이터 모델 측면에서의 검토](#데이터-모델-측면에서의-검토)\
　　 [소트가 발생하지 않도록 SQL 작성](#소트가-발생하지-않도록-sql-작성)\
　　　 [가. Union을 Union All로 대체](#가-union을-union-all로-대체)\
　　　 [나. Distinct를 Exists 서브쿼리로 대체](#나-distinct를-exists-서브쿼리로-대체)\
　　　 [다. 불필요한 Count 연산 제거](#다-불필요한-count-연산-제거)\
　　 [인덱스를 이용한 소트 연산 대체](#인덱스를-이용한-소트-연산-대체)\
　　　 [가. Sort Order By 대체](#가-sort-order-by-대체)\
　　　 [나. Sort Group By 대체](#나-sort-group-by-대체)\
　　　 [다. 인덱스를 활용한 Min, Max 구하기](#다-인덱스를-활용한-min-max-구하기)\
　　 [소트 영역을 적게 사용하도록 SQL 작성](#소트-영역을-적게-사용하도록-sql-작성)\
　　　 [가. 소트 완료 후 데이터 가공](#가-소트-완료-후-데이터-가공)\
　　　 [나. Top-N 쿼리](#나-top-n-쿼리)\
　　 [소트 영역 크기 조정](#소트-영역-크기-조정)\
　 [DML 튜닝](#dml-튜닝)\
　　 [Insert 튜닝](#insert-튜닝)\
　　　 [가. Oracle Insert 튜닝](#가-oracle-insert-튜닝)\
　　　 [나. SQL Server Insert 튜닝](#나-sql-server-insert-튜닝)\
　　 [Update 튜닝](#update-튜닝)\
　　　 [가. Truncate &amp; Insert 방식 사용](#가-truncate-amp-insert-방식-사용)\
　　　 [나. 조인을 내포한 Update 튜닝](#나-조인을-내포한-update-튜닝)\
　 [파티션 활용](#파티션-활용)\
　　 [파티션 유형](#파티션-유형)\
　　　 [가. 정적(Static) 파티션 Pruning](#가-정적static-파티션-pruning)\
　　　 [나. 동적(Dynamic) 파티션 Pruning](#나-동적dynamic-파티션-pruning)\
　　 [인덱스 파티셔닝](#인덱스-파티셔닝)\
　　　 [가. Local 파티션 인덱스 vs. Global 파티션 인덱스](#가-local-파티션-인덱스-vs-global-파티션-인덱스)\
　　　 [나. Prefixed 파티션 인덱스 vs. NonPrefixed 파티션 인덱스](#나-prefixed-파티션-인덱스-vs-nonprefixed-파티션-인덱스)\
　　　 [다. 인덱스 파티셔닝 가이드](#다-인덱스-파티셔닝-가이드)\
　 [배치 프로그램 튜닝](#배치-프로그램-튜닝)\
　　　 [가. 배치 프로그램이란](#가-배치-프로그램이란)\
　　　 [나. 배치 환경의 변화](#나-배치-환경의-변화)\
　　　 [다. 성능 개선 목표 설정](#다-성능-개선-목표-설정)\
　　　 [라. 배치 프로그램 구현 패턴과 튜닝 방안](#라-배치-프로그램-구현-패턴과-튜닝-방안)\
　　　 [가. Query Coordinator와 병렬 서버 프로세스](#가-query-coordinator와-병렬-서버-프로세스)\
　　　 [나](#나)\
　　　 [다. 테이블 큐](#다-테이블-큐)\
　　　 [라. IN-OUT 오퍼레이션](#라-in-out-오퍼레이션)\
　　　 [마](#마)\
　　　 [데이터](#데이터)\
　　　 [재분배](#재분배)\
　　　 [바](#바)\
　　　 [사. 병렬 처리 시 주의사항](#사-병렬-처리-시-주의사항)\
 # 엔터티
\
\

 ## 엔터티의 개념
\
\
데이터 모델을 이해할 때 가장 명확하게 이해해야 하는 개념 중에 하나가 바로 엔터티(Entity)이다. 이것은 우리말로 실체, 객체라고 번역하기도 하는데 실무적으로 엔터티라는 외래어를 많이 사용하기 때문에 본 가이드에서는 엔터티라는 용어를 그대로 사용하기로 한다. 엔터티에 대해서 데이터 모델과 데이터베이스에 권위자가 정의한 사항은 다음과 같다.\
\
\
변별할 수 있는 사물 - Peter Chen (1976) -\
데이터베이스 내에서 변별 가능한 객체 - C.J Date (1986) -\
정보를 저장할 수 있는 어떤 것 - James Martin (1989) -\
정보가 저장될 수 있는 사람, 장소, 물건, 사건 그리고 개념 등 - Thomas Bruce (1992) - 위 정의들의 공통점은 다음과 같다.\
\
\
엔터티는 사람, 장소, 물건, 사건, 개념 등의 명사에 해당한다.\
엔터티는 업무상 관리가 필요한 관심사에 해당한다.\
엔터티는 저장이 되기 위한 어떤 것(Thing)이다.\
엔터티란 “업무에 필요하고 유용한 정보를 저장하고 관리하기 위한 집합적인 것(Thing)”으로 설명할 수 있다. 또는, 엔터티는 업무 활동상 지속적인 관심을 가지고 있어야 하는 대상으로서 그 대상들 간에 동질성을 지닌 인스턴스들이나 그들이 행하는 행위의 집합으로 정의할 수 있다. 엔터티는 그 집합에 속하는 개체들의 특성을 설명할 수 있는 속성(Attribute)을 갖는데, 예를 들어 ‘학생’이라는 엔터티는 학번, 이름, 이수학점, 등록일자, 생일, 주소, 전화번호, 전공 등의 속성으로 특징지어질 수 있다. 이러한 속성 가운데에는 엔터티 인스턴스 전체가 공유할 수 있는 공통 속성도 있고, 엔터티 인스턴스 중 일부에만 해당하는 개별 속성도 있을 수 있다. 또한 엔터티는 인스턴스의 집합이라고 말할 수 있고, 반대로 인스턴스라는 것은 엔터티의 하나의 값에 해당한다고 정의할 수 있다. 예를 들어 과목은 수학, 영어, 국어가 존재할 수 있는데 수학, 영어, 국어는 각각이 과목이라는 엔터티의 인스턴스들이라고 할 수 있다. 또한 사건이라는 엔터티에는 사건번호2010-001, 2010-002 등의 사건이 인스턴스가 될 수 있다. 엔터티를 이해할 때 눈에 보이는(Tangible)한 것만 엔터티로 생각해서는 안되며 눈에 보이지 않는 개념 등에 대해서도 엔터티로서 인식을 할 수 있어야 한다. 실제 업무상에는 눈에 보이지 않는 것(Thing)이 엔터티로 도출되는 경우가 많기 때문에 더더욱 주의할 필요가 있다. \
\
![IMAGE](index_files/Image_001.jpg)\
\

 ## 엔터티와 인스턴스에 대한 내용과 표기법
\
\
엔터티를 표현하는 방법은 각각의 표기법에 따라 조금씩 차이는 있지만 대부분 사각형으로 표현된다. 다만 이 안에 표현되는 속성의 표현방법이 조금씩 다를 뿐이다. 엔터티와 엔터티간의 ERD를 그리면 [그림 Ⅰ-1-15]와 같이 표현할 수 있다.\
\
\
![IMAGE](index_files/Image_002.jpg)\
\
[그림 Ⅰ-1-15]에서 과목, 강사, 사건은 엔터티에 해당하고 수학, 영어는 과목이라는 엔터티의 인스턴스이고 이춘식, 조시형은 강사라는 엔터티의 인스턴스이며 사건번호인 2010-001, 2010-002는 사건 엔터티에 대한 인스턴스에 해당한다.\
※ 참고 : 오브젝트 모델링에는 클래스(Class)와 오브젝트(Object)라는 개념이 있다. 클래스는 여러 개의 오브젝트를 포함하는 오브젝트 깡통이다. 이러한 개념은 정보공학의 엔터티가 인스턴스를 포함하는 개념과 비슷하다.\
위의 엔터티와 인스턴스를 표현하면 [그림 Ⅰ-1-16]과 같다.\
![IMAGE](index_files/Image_003.jpg)\
\
\
\

 ## 엔터티의 특징
엔터티는 다음과 같은 특징을 가지고 있으며 만약 도출된 엔터티가 다음의 성질을 만족하지 못하면 적절하지 않은 엔터티일 확률이 높다. \
\
반드시 해당 업무에서 필요하고 관리하고자 하는 정보이어야 한다.(예. 환자, 토익의 응시횟수, …) 유일한 식별자에 의해 식별이 가능해야 한다.\
영속적으로 존재하는 인스턴스의 집합이어야 한다.(‘한 개’가 아니라 ‘두 개 이상’) 엔터티는 업무 프로세스에 의해 이용되어야 한다.\
엔터티는 반드시 속성이 있어야 한다.\
엔터티는 다른 엔터티와 최소 한 개 이상의 관계가 있어야 한다.\
\

 ### 가. 업무에서 필요로 하는 정보
\
\
\
엔터티 특징의 첫 번째는 반드시 시스템을 구축하고자 하는 업무에서 필요로 하고 관리하고자 하는 정보여야 한다는 점이다. 예를 들어 환자라는 엔터티는 의료시스템을 개발하는 병원에서는 반드시 필요한 엔터티이지만 일반회사에서 직원들이 병에 걸려 업무에 지장을 준다하더라도 이 정보를 그 회사의 정보로서 활용하지는 않을 것이다. 즉 시스템 구축 대상인 해당업무에서 그 엔터티를 필요로 하는가를 판단하는 것이 중요하다. \
\
![IMAGE](index_files/Image_005.jpg)\
\
사람이 살아가면서 환자는 발생할 수 밖에 없다. 그러나 일반회사의 인사시스템에서는 비록 직원들에 의해서 환자가 발생이 되지만 인사업무 영역에서 환자를 별도로 관리할 필요가 없다. 다른 예로 병원에서는 환자가 해당 업무의 가장 중요한 엔터티가 되어 꼭 관리해야 할 엔터티가 된다. 이와 같이 엔터티를 도출할 때는 업무영역 내에서 관리할 필요가 있는지를 먼저 판단하는 것이 중요하다.\
\

 ### 나. 식별이 가능해야 함
\
\
\
두 번째는 식별자(Unique Identifier)에 의해 식별이 가능해야 한다는 점이다. 어떤 엔터티이건 임의의 식별자(일련번호)를 부여하여 유일하게 만들 수는 있지만, 엔터티를 도출하는 경우에 각각의 업무적으로 의미를 가지는 인스턴스가 식별자에 의해 한 개씩만 존재하는지 검증해 보아야 한다. 유일한 식별자는 그 엔터티의 인스턴스만의 고유한 이름이다. 두 개 이상의 엔터티를 대변하면 그
